# 基本概念

云容器管理提供强可扩展性、高性能的企业级 Kubernetes 集群，支撑云原生化应用的运行。借助云容器管理，您可以在容器云上轻松部署、管理和扩展容器化应用。并且提供

云容器管理提供 Kubernetes 原生 API，支持使用 kubectl，且提供图形化控制台，

#### 集群 Cluster 

集群指容器运行所需要的云资源组合，关联了若干云服务器节点。您可以在集群中运行您的应用程序，基于云容器管理 平台，我们可以创建若干集群或者接入若干 Kubernetes 标准集群。

#### 节点 Node

每一个节点对应一台虚拟机/物理服务器，所有的容器应用运行在集群的节点上。容器平台上的系统组件，默认运行在控制器节点上，用于管理节点上运行的容器实例。集群中的节点数量可以进行扩缩容，节点类型分为：控制器节点（Controller）及工作节点（Worker）。

#### 容器组 Pod

容器组 是 Kubernetes 部署应用或服务的最小的基本单位。一个容器组可以 封装一个或多个应用容器、存储资源、一个独立的网络 IP， 这些容器是相对紧密的耦合在一起的。 

#### 容器 Container

容器是通过容器镜像部署运行的实例，容器将应用程序从底层的主机设施中解耦，因此在不同的云或 OS 环境中应用程序的部署部署更容易。

#### 工作负载 Workload

工作负载是在 Kubernetes 上运行的应用程序。

无论工作负载是单一组件还是由多个一同工作的组件构成，在 Kubernetes 中你 可以在一组 [Pods](https://kubernetes.io/zh/docs/concepts/workloads/pods) 中运行它。

在 Kubernetes 提供若干种内置的工作负载资源：

- **无状态服务** (Deployments)：容器组之间完全独立、功能相同，具有弹性伸缩、滚动升级等特性。常用来部署无状态应用实现快速的伸缩，相较于有状态服务，实例数量可以灵活伸缩。如：nginx、wordpress，创建无状态（deployment）服务请参考 
- **有状态服务** (StatefulSets)：容器组之间不完全独立，具有稳定的持久化存储和网络标示，以及有序的部署、收缩和删除等特性。因为容器可以在不同主机间迁移，所以在主机上并不会保存数据，通过将存储卷挂载在容器上，从而实现有状态（Statefulset）服务的数据持久化，例如 mysql-HA、etcd。
- **守护进程服务** (Daemonset)：容器组之间完全独立，保证在在分配的节点中持续执行后台任务，而无需用户干预。守护进程 (DaemonSet) 服务在每个节点创建一个 Pod，您可以选择部署的一个特定节点。守护进程示例包括像 [Fluentd](https://www.fluentd.org/) 之类的日志收集器和监控服务。
- **普通任务**（Job）：普通任务是一次性运行的短任务，部署完成后即可执行。使用场景为在创建工作负载前，执行普通任务，将镜像上传至镜像仓库。
- **定时任务**（CronJob）：定时任务是按照指定时间周期运行的短任务。使用场景为在某个固定时间点，为所有运行中的节点做时间同步。

**服务与容器间的关系**

一个服务由一个或多个容器组（Pod）组成。一个容器组由一个或多个容器组成，每个容器都对应一个容器镜像。对于无状态工作负载，容器组都是完全相同的。

#### 应用模板

标准模板的统一资源管理和调度，并进行相关功能扩展。您可以基于应用模板管理和部署社区标准应用模板，以及自定义业务应用模板。

#### 镜像 Image 

容器镜像是一个容器应用打包的标准格式的模板，用于创建容器。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

例如：一个镜像可以包含一个完整的 Ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序

#### 命名空间 Namespace

命名空间是对一组资源和对象的抽象整合。在同一个集群内可创建不同的命名空间，不同命名空间中的数据彼此隔离。使得它们既可以共享同一个集群的服务，也能够互不干扰。例如：

- 可以将开发环境、测试环境的业务分别放在不同的命名空间。
- 常见的 Pods，Services，Replication Controllers 和 Deployments 等都是属于某一个 Namespace 的（默认是Default），而 Node，PersistentVolumes 等则不属于任何 Namespace。

#### 服务 Service

Service是将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。

使用Kubernetes，您无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes为Pods提供自己的IP地址和一组Pod的单个DNS名称，并且可以在它们之间进行负载平衡。

Kubernetes允许指定一个需要的类型的 Service，类型 的取值以及行为如下：

- ClusterIP：集群内访问。通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 ServiceType。
- NodePort：节点访问。通过每个Node上的 IP 和静态端口（NodePort）暴露服务。NodePort服务会路由到ClusterIP服务，这个ClusterIP 服务会自动创建。通过请求 <NodeIP>:<NodePort>，可以从集群的外部访问一个 NodePort 服务。
- LoadBalancer：负载均衡。使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到NodePort服务和ClusterIP服务。

#### 七层负载均衡 Ingress 

Ingress 是为进入集群的请求提供路由规则的集合，可以给 Service 提供集群外部访问的 URL、负载均衡、SSL 终止、HTTP 路由等。

#### 网络策略 NetworkPolicy 

NetworkPolicy 提供了基于策略的网络控制，用于隔离应用并减少攻击面。它使用标签选择器模拟传统的分段网络，并通过策略控制它们之间的流量以及来自外部的流量。

#### 配置项 Configmap 

ConfigMap 用于保存配置非机密性的数据保存到键值对中。使用时， 容器组可以将其用作环境变量、命令行参数或者存储卷中的配置文件。

ConfigMap 将您的环境配置信息和容器镜像解耦，便于应用配置的修改。

#### 密钥 Secret

Secret 类似于 Configmap ，但用于保存机密数据（如密码、Token、秘钥等）的配置信息， Secret 将敏感信息和容器镜像解耦，不需要在应用程序代码中包含机密数据。

#### 标签 Label

标签其实就一对 key/value，被关联到对象上，比如Pod。标签的使用我们倾向于能够标示对象的特殊特点，并且对用户而言是有意义的，但是标签对内核系统是没有直接意义的。

Label 是附着到特定对象上（例如 容器组）的键值对。可在创建对象 时指定，也可以在对象创建后指定，Labels 的键值对系统本身并没有什么含义，仅对用户才有意义。

#### 选择器 LabelSelector

Label Selector 是 Kubernetes 核心的分组机制，通过 Label Selector 客户端/用户能够识别一组有共同特征或属性的资源对象。

#### 注解 Annotation

Annotation 可以将 Kubernetes 资源对象关联到任意的非标识性元数据。可以通过注解检索到这些元数据。

Annotation与Label类似，也使用 Key/Value 键值对的形式进行定义。

#### 存储卷 PersistentVolume

PersistentVolume (PV) 和 PersistentVolumeClaim (PVC) 提供了方便的持久化卷：PV 提供网络存储资源，而 PVC 请求存储资源。

#### 存储声明 PersistentVolumeClaim

PV 是存储资源，而 PersistentVolumeClaim (PVC) 是对 PV 的请求。PVC 跟 Pod 类似：Pod 消费 Node 资源，而 PVC 消费 PV 资源；Pod 能够请求 CPU 和内存资源，而 PVC 请求特定大小和访问模式的数据卷。

#### 弹性伸缩 HPA 

Horizontal Pod Autoscaling，简称 HPA，是Kubernetes中实现POD水平自动伸缩的功能。Kubernetes集群可以通过Replication Controller的scale机制完成服务的扩容或缩容，实现具有伸缩性的服务。

#### 亲和性与反亲和性

 亲和性和反亲和性扩展了你可以定义的约束类型。使用亲和性与反亲和性的一些好处有：

- 亲和性、反亲和性语言的表达能力更强。`nodeSelector` 只能选择拥有所有指定标签的节点。 亲和性、反亲和性为你提供对选择逻辑的更强控制能力。
- 你可以标明某规则是“软需求”或者“偏好”，这样调度器在无法找到匹配节点时仍然调度该 Pod。
- 你可以使用节点上（或其他拓扑域中）运行的其他 Pod 的标签来实施调度约束， 而不是只能使用节点本身的标签。这个能力让你能够定义规则允许哪些 Pod 可以被放置在一起。

在应用没有容器化之前，原先一个虚机上会装多个组件，进程间会有通信。但在做容器化拆分的时候，往往直接按进程拆分容器，比如业务进程一个容器，监控日志处理或者本地数据放在另一个容器，并且有独立的生命周期。这时如果他们分布在网络中两个较远的点，请求经过多次转发，性能会很差。

- 亲和性：可以实现就近部署，增强网络能力实现通信上的就近路由，减少网络的损耗。如：应用A与应用B两个应用频繁交互，所以有必要利用亲和性让两个应用的尽可能的靠近，甚至在一个节点上，以减少因网络通信而带来的性能损耗。
- 反亲和性：主要是出于高可靠性考虑，尽量分散实例，某个节点故障的时候，对应用的影响只是 N 分之一或者只是一个实例。如：当应用采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个节点上，以提高HA。

#### 节点亲和性 NodeAffinity 

通过选择标签的方式，可以限制容器组被调度到特定的节点上。

#### 节点反亲和性 NodeAntiAffinity

通过选择标签的方式，可以限制容器组不被调度到特定的节点上。

#### 容器组负载亲和性 PodAffinity

指定工作负载部署在相同节点。用户可根据业务需求进行工作负载的就近部署，容器间通信就近路由，减少网络消耗。

#### 容器组反亲和性 PodAntiAffinity

指定工作负载部署在不同节点。同个工作负载的多个实例反亲和部署，减少宕机影响；互相干扰的应用反亲和部署，避免干扰。

#### 资源配额 Resource Quota

资源配额（Resource Quotas）是用来限制用户资源用量的一种机制。

#### 资源限制 Limit Range

默认情况下，Kubernetes 中所有容器都没有任何 CPU 和内存限制。LimitRange 用来给 Namespace 增加一个资源限制，包括最小、最大和默认资源。在容器组创建时，强制执行使用limits的参数分配资源。

#### 环境变量

环境变量是指容器运行环境中设定的一个变量，您可以在创建容器模板时设定不超过30个的环境变量。环境变量可以在工作负载部署后修改，为工作负载提供了极大的灵活性。

